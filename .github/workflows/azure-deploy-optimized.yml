name: Deploy to Azure (F1 Tier)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  NODE_VERSION: '18.x'
  AZURE_WEBAPP_NAME: buddy-chat-app
  AZURE_BACKEND_NAME: chat-app-backend-123
  AZURE_RESOURCE_GROUP: chat-app-rg

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-client:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    # Install and build client (optimized with chunking)
    - name: Build client
      run: |
        echo "Installing core dependencies..."
        npm install --no-audit --prefer-offline --legacy-peer-deps \
          react react-dom react-scripts typescript @types/react @types/react-dom

        echo "Installing UI dependencies..."
        npm install --no-audit --prefer-offline --legacy-peer-deps \
          @mui/material @mui/icons-material @emotion/react @emotion/styled

        echo "Installing remaining dependencies..."
        npm install --no-audit --prefer-offline --legacy-peer-deps

        echo "Clearing caches..."
        npm cache clean --force
        rm -rf node_modules/.cache

        echo "Building client in production mode..."
        export NODE_OPTIONS="--max-old-space-size=4096"
        GENERATE_SOURCEMAP=false \
        INLINE_RUNTIME_CHUNK=false \
        DISABLE_ESLINT_PLUGIN=true \
        TSC_COMPILE_ON_ERROR=true \
        SKIP_PREFLIGHT_CHECK=true \
        BABEL_ENV=production \
        CI=false \
        npm run build:client

        echo "Optimizing build output..."
        find build -type f -name "*.map" -delete
        find build -type f -name "*.txt" -delete
        find build -type f -name "LICENSE*" -delete
        find build -type f -name "asset-manifest.json" -delete

    # Package frontend (optimized for F1 tier)
    - name: Package frontend
      run: |
        echo "Packaging frontend..."
        cd build
        # Only include essential files
        zip -r ../frontend.zip . -x "*.map" "*.txt" "*.md"

    - name: Upload frontend artifact
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend.zip
        retention-days: 1

  build-server:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    # Install dependencies and build server
    - name: Build server
      run: |
        echo "Installing production dependencies..."
        npm install --no-audit --prefer-offline --omit=dev --production --legacy-peer-deps
        
        echo "Building server..."
        npm run build:server
      env:
        CI: true
        NODE_OPTIONS: --max-old-space-size=512

    # Package backend (optimized for F1 tier)
    - name: Package backend
      run: |
        echo "Packaging backend..."
        mkdir -p backend-temp/server
        
        # Copy only production server files
        cp -r build/server/* backend-temp/server/
        
        # Create minimal package.json for production
        node -e "const pkg=require('./package.json'); \
          const newPkg={ \
            name: pkg.name, \
            version: pkg.version, \
            type: pkg.type, \
            dependencies: { \
              'express': pkg.dependencies.express, \
              'express-oauth2-jwt-bearer': pkg.dependencies['express-oauth2-jwt-bearer'], \
              'mongodb': pkg.dependencies.mongodb, \
              'redis': pkg.dependencies.redis \
            } \
          }; \
          require('fs').writeFileSync('backend-temp/package.json', JSON.stringify(newPkg, null, 2));"
        
        # Create optimized backend zip
        cd backend-temp
        zip -r ../backend.zip . -x "*.map" "*.txt" "*.md"

    - name: Upload backend artifact
      uses: actions/upload-artifact@v4
      with:
        name: backend-build
        path: backend.zip
        retention-days: 1

  deploy:
    needs: [build-client, build-server]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        app: [frontend, backend]
        include:
          - app: frontend
            name: buddy-chat-app
            artifact: frontend-build
            startup: "pm2 serve /home/site/wwwroot --no-daemon --spa"
          - app: backend
            name: chat-app-backend-123
            artifact: backend-build
            startup: "pm2 start /home/site/wwwroot/server/server.js --name backend --no-daemon --no-autorestart --max-memory-restart 128M --node-args='--max-old-space-size=128'"
    environment:
      name: Production
      url: ${{ matrix.app == 'frontend' && format('https://{0}.azurewebsites.net', env.AZURE_WEBAPP_NAME) || format('https://{0}.azurewebsites.net', env.AZURE_BACKEND_NAME) }}
    steps:
    - name: Download artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: .

    - name: Azure login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy application
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Deploy with zip package (optimized for F1 tier)
          echo "Deploying ${{ matrix.app }}..."
          
          # Function to deploy with retries
          deploy_with_retries() {
            local max_attempts=3
            local attempt=1
            local delay=30
            
            while [ $attempt -le $max_attempts ]; do
              echo "Deployment attempt $attempt of $max_attempts..."
              
              az webapp deploy \
                --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
                --name ${{ matrix.name }} \
                --src-path "${{ matrix.app }}.zip" \
                --type zip \
                --async true \
                --restart true \
                --timeout 300 && return 0
              
              echo "Deployment failed, waiting ${delay}s before retry..."
              sleep $delay
              attempt=$((attempt + 1))
              delay=$((delay * 2))
            done
            
            return 1
          }
          
          deploy_with_retries
          
          # Configure app settings and web app
          echo "Configuring web app settings..."
          
          # Update minimal app settings for F1 tier
          az webapp config appsettings set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ matrix.name }} \
            --settings \
              SCM_DO_BUILD_DURING_DEPLOYMENT=false \
              WEBSITE_NODE_DEFAULT_VERSION=18-lts \
              WEBSITE_RUN_FROM_PACKAGE=1 \
              NODE_ENV=production \
              ${{ matrix.app == 'backend' && format('COSMOS_DB_CONNECTION_STRING={0}', secrets.COSMOS_DB_CONNECTION_STRING) || '' }} \
              ${{ matrix.app == 'backend' && format('REDIS_CONNECTION_STRING={0}', secrets.REDIS_CONNECTION_STRING) || '' }}

  health-check:
    needs: deploy
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - name: Azure login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Health Check
      run: |
        check_health() {
          local url=$1
          local name=$2
          local max_retries=5
          local retry_delay=30
          local retry=0
          
          while [ $retry -lt $max_retries ]; do
            status=$(curl -sL -o /dev/null -w "%{http_code}" $url || echo "000")
            if [ "$status" = "200" ]; then
              echo "$name is healthy (Status: $status)"
              return 0
            fi
            
            echo "$name not ready (Status: $status), retrying in ${retry_delay}s... (Attempt $((retry+1))/$max_retries)"
            sleep $retry_delay
            retry=$((retry+1))
          done
          
          echo "$name failed health check after $max_retries attempts"
          return 1
        }

        # Check frontend first, then backend
        check_health "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" "${{ env.AZURE_WEBAPP_NAME }}"
        frontend_status=$?
        
        check_health "https://${{ env.AZURE_BACKEND_NAME }}.azurewebsites.net/health" "${{ env.AZURE_BACKEND_NAME }}"
        backend_status=$?
        
        if [ $frontend_status -ne 0 ] || [ $backend_status -ne 0 ]; then
          echo "Health check failed"
          exit 1
        fi
