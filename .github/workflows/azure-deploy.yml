name: Deploy to Azure

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  NODE_VERSION: '18.x'
  AZURE_WEBAPP_NAME: buddy-chat-app
  AZURE_BACKEND_NAME: chat-app-backend-123
  AZURE_RESOURCE_GROUP: chat-app-rg

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.value }}
    steps:
    - uses: actions/checkout@v3

    - name: Generate cache key
      id: cache-key
      run: echo "value=${{ hashFiles('package-lock.json', 'package.json') }}" >> $GITHUB_OUTPUT

    - name: Cache node modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: npm-deps-${{ steps.cache-key.outputs.value }}
        restore-keys: |
          npm-deps-

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build application
      run: |
        npm run build
      env:
        CI: false

    - name: Cache build output
      uses: actions/cache@v3
      with:
        path: |
          build
          build/server
        key: build-output-${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Restore build output
      uses: actions/cache@v3
      with:
        path: |
          build
          build/server
        key: build-output-${{ github.sha }}

    - name: Azure login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        enable-AzPSSession: true

    - name: Deploy Frontend and Backend
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Configure and deploy frontend
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --linux-fx-version "NODE|18-lts"
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --startup-file "pm2 serve /home/site/wwwroot --no-daemon --spa"
          az webapp deploy --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --src-path ./build --type zip &
          
          # Configure and deploy backend
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_BACKEND_NAME }} --linux-fx-version "NODE|18-lts"
          az webapp config set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_BACKEND_NAME }} --startup-file "pm2 start /home/site/wwwroot/server.js --name backend --no-daemon --wait-ready --listen-timeout 10000"
          az webapp deploy --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_BACKEND_NAME }} --src-path ./build/server --type zip &
          
          wait # Wait for parallel deployments to complete

    - name: Configure App Settings
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Frontend settings
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --settings \
            PRE_BUILD_COMMAND="npm install -g pm2" \
            SCM_DO_BUILD_DURING_DEPLOYMENT=true &

          # Backend settings
          az webapp config appsettings set --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_BACKEND_NAME }} --settings \
            PRE_BUILD_COMMAND="npm install -g pm2" \
            SCM_DO_BUILD_DURING_DEPLOYMENT=true \
            COSMOS_DB_CONNECTION_STRING="${{ secrets.COSMOS_DB_CONNECTION_STRING }}" \
            REDIS_CONNECTION_STRING="${{ secrets.REDIS_CONNECTION_STRING }}" \
            NODE_ENV=production &

          wait # Wait for parallel configurations to complete

    - name: Health Check
      run: |
        check_health() {
          local url=$1
          local name=$2
          local max_retries=10
          local retry_delay=10
          local retry=0
          
          while [ $retry -lt $max_retries ]; do
            status=$(curl -s -o /dev/null -w "%{http_code}" $url)
            if [ "$status" = "200" ]; then
              echo "$name is healthy (Status: $status)"
              return 0
            fi
            echo "$name not ready (Status: $status), retrying in ${retry_delay}s... (Attempt $((retry+1))/$max_retries)"
            sleep $retry_delay
            retry=$((retry+1))
          done
          
          echo "$name failed health check after $max_retries attempts"
          az webapp log tail --name $name --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
          return 1
        }

        # Run health checks in parallel
        check_health "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" "${{ env.AZURE_WEBAPP_NAME }}" &
        frontend_pid=$!
        
        check_health "https://${{ env.AZURE_BACKEND_NAME }}.azurewebsites.net/health" "${{ env.AZURE_BACKEND_NAME }}" &
        backend_pid=$!
        
        # Wait for both checks and capture exit codes
        wait $frontend_pid
        frontend_status=$?
        wait $backend_pid
        backend_status=$?
        
        # Exit with error if either check failed
        [ $frontend_status -eq 0 ] && [ $backend_status -eq 0 ]
