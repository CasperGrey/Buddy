name: Deploy to Azure

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  NODE_VERSION: '18.x'
  AZURE_WEBAPP_NAME: buddy-chat-app
  AZURE_BACKEND_NAME: chat-app-backend-123
  AZURE_RESOURCE_GROUP: chat-app-rg

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.value }}
    steps:
    - uses: actions/checkout@v4

    # Improved cache key generation using multiple dependency files
    - name: Generate cache key
      id: cache-key
      run: |
        echo "value=$(find . -name 'package-lock.json' -o -name 'package.json' -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT

    # Optimized node modules caching with better restore keys
    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: |
          **/node_modules
          ~/.npm
        key: ${{ runner.os }}-npm-${{ steps.cache-key.outputs.value }}
        restore-keys: |
          ${{ runner.os }}-npm-
          ${{ runner.os }}-

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    # Parallel installation of dependencies
    - name: Install dependencies
      run: |
        npm ci --prefer-offline --no-audit
      env:
        NODE_OPTIONS: --max-old-space-size=4096

    # Optimized build with parallel processing
    - name: Build application
      run: |
        npm run build
      env:
        CI: false
        NODE_OPTIONS: --max-old-space-size=4096

    # Split artifacts for better handling
    - name: Upload frontend artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: build
        if-no-files-found: error
        retention-days: 1

    - name: Upload backend artifacts
      uses: actions/upload-artifact@v4
      with:
        name: backend-build
        path: build/server
        if-no-files-found: error
        retention-days: 1

  deploy-frontend:
    needs: build
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Download frontend artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: ./frontend-dist

    - name: Azure login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy Frontend
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Configure frontend
          az webapp config set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --linux-fx-version "NODE|18-lts" \
            --startup-file "pm2 serve /home/site/wwwroot --no-daemon --spa"

          # Verify frontend build exists
          if [ ! -d "./frontend-dist" ]; then
            echo "Frontend build directory not found"
            exit 1
          fi

          # Deploy frontend with explicit path
          az webapp deploy \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --src-path "./frontend-dist" \
            --type zip \
            --async true

          # Configure frontend settings
          az webapp config appsettings set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_WEBAPP_NAME }} \
            --settings \
              PRE_BUILD_COMMAND="npm install -g pm2" \
              SCM_DO_BUILD_DURING_DEPLOYMENT=true

  deploy-backend:
    needs: build
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Download backend artifacts
      uses: actions/download-artifact@v4
      with:
        name: backend-build
        path: ./backend-dist

    - name: Azure login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Deploy Backend
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Configure backend
          az webapp config set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_BACKEND_NAME }} \
            --linux-fx-version "NODE|18-lts" \
            --startup-file "pm2 start /home/site/wwwroot/server.js --name backend --no-daemon --wait-ready --listen-timeout 10000"

          # Verify backend build exists
          if [ ! -d "./backend-dist" ]; then
            echo "Backend build directory not found"
            exit 1
          fi

          # Deploy backend with explicit path
          az webapp deploy \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_BACKEND_NAME }} \
            --src-path "./backend-dist" \
            --type zip \
            --async true

          # Configure backend settings
          az webapp config appsettings set \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AZURE_BACKEND_NAME }} \
            --settings \
              PRE_BUILD_COMMAND="npm install -g pm2" \
              SCM_DO_BUILD_DURING_DEPLOYMENT=true \
              COSMOS_DB_CONNECTION_STRING="${{ secrets.COSMOS_DB_CONNECTION_STRING }}" \
              REDIS_CONNECTION_STRING="${{ secrets.REDIS_CONNECTION_STRING }}" \
              NODE_ENV=production

  health-check:
    needs: [deploy-frontend, deploy-backend]
    runs-on: ubuntu-latest
    steps:
    - name: Azure login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Health Check
      run: |
        check_health() {
          local url=$1
          local name=$2
          local max_retries=15
          local retry_delay=20
          local retry=0
          
          while [ $retry -lt $max_retries ]; do
            status=$(curl -s -o /dev/null -w "%{http_code}" $url || echo "000")
            if [ "$status" = "200" ]; then
              echo "$name is healthy (Status: $status)"
              return 0
            fi
            echo "$name not ready (Status: $status), retrying in ${retry_delay}s... (Attempt $((retry+1))/$max_retries)"
            sleep $retry_delay
            retry=$((retry+1))
          done
          
          echo "$name failed health check after $max_retries attempts"
          az webapp log tail --name $name --resource-group ${{ env.AZURE_RESOURCE_GROUP }}
          return 1
        }

        # Run health checks in parallel with improved error handling
        check_health "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net" "${{ env.AZURE_WEBAPP_NAME }}" &
        frontend_pid=$!
        
        check_health "https://${{ env.AZURE_BACKEND_NAME }}.azurewebsites.net/health" "${{ env.AZURE_BACKEND_NAME }}" &
        backend_pid=$!
        
        # Wait for both checks and capture exit codes
        wait $frontend_pid
        frontend_status=$?
        wait $backend_pid
        backend_status=$?
        
        # Exit with error if either check failed
        [ $frontend_status -eq 0 ] && [ $backend_status -eq 0 ]
