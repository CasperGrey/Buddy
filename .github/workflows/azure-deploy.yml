name: Deploy to Azure

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'api/**'
      - 'public/**'
      - 'package.json'
      - '.github/workflows/azure-deploy.yml'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read
  deployments: write

env:
  DOTNET_VERSION: '8.0.x'
  NODE_VERSION: '18.x'
  BACKEND_APP_NAME: chat-functions-prod
  BACKEND_RG: rg-chat-prod-001
  FRONTEND_APP_NAME: buddy-chat-app
  FRONTEND_RG: chat-app-frontend-rg

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-deploy-backend:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Build and Package
      run: |
        cd api/ChatFunctions
        dotnet restore
        dotnet publish --configuration Release --output ./output
        
        # Verify published output
        echo "Verifying published output..."
        if [ ! -f "output/ChatFunctions.dll" ] || [ ! -f "output/host.json" ]; then
          echo "Error: Required files missing from publish output"
          echo "Contents of output directory:"
          ls -la output/
          exit 1
        fi
        
        # Copy project file needed for function app packaging
        echo "Copying project file..."
        cp ChatFunctions.csproj output/
        if [ ! -f "output/ChatFunctions.csproj" ]; then
          echo "Error: Failed to copy project file"
          exit 1
        fi
        
        # Install Azure Functions Core Tools
        echo "Installing Azure Functions Core Tools..."
        if ! command -v func &> /dev/null; then
          wget -q https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb
          sudo dpkg -i packages-microsoft-prod.deb
          sudo apt-get update
          sudo apt-get install -y azure-functions-core-tools-4
          rm packages-microsoft-prod.deb
        fi
        
        # Verify installation
        func --version
        
        # Ensure function project file exists
        if [ ! -f "output/ChatFunctions.csproj" ]; then
          echo "Error: Function project file not found in output directory"
          exit 1
        fi
        
        # Create .functions directory if it doesn't exist
        mkdir -p output/.functions
        
        cd output
        # Create function app package
        echo "Creating function app package..."
        zip -r ChatFunctions.zip . \
          --exclude "*.pdb" \
          --exclude "ref/*" \
          --exclude "*.xml"
        
        # Verify package contents
        echo "Verifying package contents..."
        ls -la
        if [ -f "ChatFunctions.zip" ]; then
          echo "Package created successfully"
        else
          echo "Error: Package creation failed"
          exit 1
        fi

    - name: Configure environment
      run: |
        echo "Setting up deployment environment..."
        echo "GITHUB_REF: ${{ github.ref }}"
        echo "GITHUB_SHA: ${{ github.sha }}"
        echo "GITHUB_ENVIRONMENT: Production"

    - name: Azure login
      id: azure_login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_BACKEND_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_BACKEND_SUBSCRIPTION_ID }}
      continue-on-error: true

    - name: Check Azure login
      if: steps.azure_login.outcome == 'failure'
      run: |
        echo "Azure login failed. Please ensure:"
        echo "1. Federated credentials are set up using setup-federated-credentials.ps1"
        echo "2. The app registration has the correct permissions"
        echo "3. The GitHub repository matches the federated credential subject"
        echo "4. The GitHub environment 'production' is configured"
        exit 1

    - name: Set deployment status
      if: steps.azure_login.outcome == 'success'
      run: |
        echo "Azure login successful"
        echo "Proceeding with deployment to Production"

    - name: Verify function app configuration
      run: |
        echo "Verifying function app configuration..."
        
        # Check runtime version
        runtime_version=$(az functionapp config show \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.BACKEND_RG }} \
          --query "netFrameworkVersion" -o tsv)
        
        echo "Current runtime version: $runtime_version"
        if [[ "$runtime_version" != "v8.0" ]]; then
          echo "Updating runtime version to v8.0..."
          az functionapp config set \
            --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.BACKEND_RG }} \
            --net-framework-version "v8.0"
        fi
        
        # Verify worker runtime
        worker_runtime=$(az functionapp config appsettings list \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.BACKEND_RG }} \
          --query "[?name=='FUNCTIONS_WORKER_RUNTIME'].value" -o tsv)
        
        echo "Worker runtime: $worker_runtime"
        if [[ "$worker_runtime" != "dotnet-isolated" ]]; then
          echo "Setting worker runtime to dotnet-isolated..."
          az functionapp config appsettings set \
            --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.BACKEND_RG }} \
            --settings FUNCTIONS_WORKER_RUNTIME=dotnet-isolated
        fi
        
        # Verify other critical settings
        echo "Verifying other settings..."
        az functionapp config appsettings set \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.BACKEND_RG }} \
          --settings \
            WEBSITE_RUN_FROM_PACKAGE=1 \
            FUNCTIONS_EXTENSION_VERSION=~4 \
            SCM_DO_BUILD_DURING_DEPLOYMENT=false

    - name: Verify deployment package
      run: |
        echo "Verifying deployment package..."
        if [ ! -f "api/ChatFunctions/output/ChatFunctions.zip" ]; then
          echo "Error: Deployment package not found"
          echo "Contents of output directory:"
          ls -la api/ChatFunctions/output/
          exit 1
        fi
        
        # Check zip file size and contents
        echo "Package size: $(stat -c%s "api/ChatFunctions/output/ChatFunctions.zip") bytes"
        echo "Package contents:"
        unzip -l "api/ChatFunctions/output/ChatFunctions.zip"

    - name: Get publish profile
      run: |
        echo "Verifying function app exists..."
        if ! az functionapp show \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.BACKEND_RG }} \
          --query id -o tsv &>/dev/null; then
          echo "Error: Function app not found"
          exit 1
        fi
        
        echo "Getting function app publish profile..."
        profile=$(az functionapp deployment list-publishing-profiles \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.BACKEND_RG }} \
          --xml)
        
        if [ -z "$profile" ]; then
          echo "Error: Failed to get publish profile"
          echo "Function app exists but failed to get profile. Check permissions."
          exit 1
        fi
        
        echo "Successfully retrieved publish profile"
        echo "PUBLISH_PROFILE=$profile" >> $GITHUB_ENV

    - name: Deploy Function App
      id: deploy_function
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ env.BACKEND_APP_NAME }}
        package: 'api/ChatFunctions/output/ChatFunctions.zip'
        respect-funcignore: true
        enable-oryx-build: false
        publish-profile: ${{ env.PUBLISH_PROFILE }}

    - name: Verify deployment
      if: steps.deploy_function.outcome == 'success'
      run: |
        echo "Deployment completed, checking function app status..."
        
        # Get function app status
        status=$(az functionapp show \
          --name ${{ env.BACKEND_APP_NAME }} \
          --resource-group ${{ env.BACKEND_RG }} \
          --query state -o tsv)
        
        echo "Function app status: $status"
        
        if [ "$status" != "Running" ]; then
          echo "Error: Function app is not running"
          
          # Get recent logs
          echo "Recent logs:"
          az functionapp logs tail \
            --name ${{ env.BACKEND_APP_NAME }} \
            --resource-group ${{ env.BACKEND_RG }} \
            --limit 50
          
          exit 1
        fi

    - name: Wait for backend deployment
      run: |
        check_health() {
          local url=$1
          local max_retries=10
          local retry=0
          local delay=30
          
          while [ $retry -lt $max_retries ]; do
            # Get detailed response including headers
            echo "Checking health (Attempt $((retry+1))/$max_retries)..."
            response=$(curl -sL -D - "$url" -o /dev/null)
            status=$(echo "$response" | grep -i "^HTTP" | tail -n1 | awk '{print $2}')
            
            if [ "$status" = "200" ]; then
              echo "Backend is healthy (Status: $status)"
              return 0
            fi
            
            echo "Backend not ready (Status: $status)"
            echo "Response headers:"
            echo "$response"
            
            # Get function app logs if available
            echo "Recent function logs:"
            az functionapp logs tail \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.BACKEND_RG }} \
              --limit 25 || true
            
            # Check application settings
            echo "Verifying application settings..."
            az functionapp config appsettings list \
              --name ${{ env.BACKEND_APP_NAME }} \
              --resource-group ${{ env.BACKEND_RG }} \
              --query "[?name=='FUNCTIONS_WORKER_RUNTIME']" || true
            
            echo "Retrying in ${delay}s..."
            sleep $delay
            retry=$((retry+1))
          done
          
          echo "Backend failed health check after $max_retries attempts"
          return 1
        }

        check_health "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/graphql"

  validate-graphql:
    needs: build-and-deploy-backend
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install GraphQL tools
      run: |
        npm install -g get-graphql-schema
    
    - name: Wait for backend warmup
      run: |
        echo "Waiting for backend to warm up..."
        sleep 30
    
    - name: Azure login
      id: azure_login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_BACKEND_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_BACKEND_SUBSCRIPTION_ID }}
      continue-on-error: true

    - name: Check Azure login
      if: steps.azure_login.outcome == 'failure'
      run: |
        echo "Azure login failed. Please ensure:"
        echo "1. Federated credentials are set up using setup-federated-credentials.ps1"
        echo "2. The app registration has the correct permissions"
        echo "3. The GitHub repository matches the federated credential subject"
        echo "4. The GitHub environment 'Production' is configured"
        exit 1

    # No environment configuration here - let Azure login handle OIDC token

    - name: Validate GraphQL Schema
      run: |
        cd api/ChatFunctions
        
        # Check if endpoint is accessible
        echo "Checking endpoint accessibility..."
        status_code=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/graphql")
        if [ "$status_code" != "200" ]; then
          echo "Error: Endpoint is not accessible (Status: $status_code)"
          exit 1
        fi
        
        # Get function key
        echo "Getting function key..."
        function_key=$(az functionapp keys list -g ${{ env.BACKEND_RG }} -n ${{ env.BACKEND_APP_NAME }} --query "functionKeys.default" -o tsv)
        
        if [ -z "$function_key" ]; then
          echo "Error: Failed to get function key"
          exit 1
        fi
        
        # Download schema using introspection
        echo "Downloading schema..."
        export GET_GRAPHQL_SCHEMA_HEADERS="x-functions-key:$function_key"
        npx get-graphql-schema --header "x-functions-key:$function_key" "https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/graphql" > schema.new.graphql
        
        if [ ! -f schema.new.graphql ]; then
          echo "Error: Failed to download schema"
          exit 1
        fi
        
        # Validate schema content
        if ! grep -q "type Query" schema.new.graphql || ! grep -q "type Mutation" schema.new.graphql; then
          echo "Error: Schema validation failed - missing Query or Mutation types"
          exit 1
        fi
        
        echo "Schema validation successful"

  build-frontend:
    needs: validate-graphql
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci --prefer-offline --no-audit

    - name: Build frontend
      run: |
        export NODE_OPTIONS="--max-old-space-size=4096"
        export REACT_APP_GRAPHQL_HTTP_URL="https://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/graphql"
        export REACT_APP_GRAPHQL_WS_URL="wss://${{ env.BACKEND_APP_NAME }}.azurewebsites.net/api/graphql-ws"
        npm run build

        echo "Optimizing build output..."
        find build -type f -name "*.map" -delete
        find build -type f -name "*.txt" -delete
        find build -type f -name "LICENSE*" -delete
        find build -type f -name "asset-manifest.json" -delete

    - name: Package frontend
      run: |
        cd build
        zip -r ../frontend.zip . -x "*.map" "*.txt" "*.md"

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend.zip
        retention-days: 1

  deploy-frontend:
    needs: build-frontend
    runs-on: ubuntu-latest
    permissions:
      deployments: write
    steps:
    - name: Download artifact
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: .

    - name: Azure login
      id: azure_login_frontend
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_FRONTEND_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_FRONTEND_SUBSCRIPTION_ID }}
      continue-on-error: true

    - name: Configure environment
      if: steps.azure_login_frontend.outcome == 'success'
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            environment: 'Production',
            auto_merge: false,
            production_environment: true,
            environment_url: 'https://${{ env.FRONTEND_APP_NAME }}.azurewebsites.net'
          })

    - name: Check Azure login
      if: steps.azure_login_frontend.outcome == 'failure'
      run: |
        echo "Azure login failed. Please ensure:"
        echo "1. Federated credentials are set up using setup-federated-credentials.ps1"
        echo "2. The app registration has the correct permissions"
        echo "3. The GitHub repository matches the federated credential subject"
        echo "4. The GitHub environment 'production' is configured"
        exit 1

    - name: Deploy frontend
      uses: azure/CLI@v1
      with:
        inlineScript: |
          deploy_with_retries() {
            local max_attempts=3
            local attempt=1
            local delay=30
            
            while [ $attempt -le $max_attempts ]; do
              echo "Deployment attempt $attempt of $max_attempts..."
              
              az webapp deploy \
                --resource-group ${{ env.FRONTEND_RG }} \
                --name ${{ env.FRONTEND_APP_NAME }} \
                --src-path "frontend.zip" \
                --type zip \
                --async true \
                --restart true \
                --timeout 300 && return 0
              
              echo "Deployment failed, waiting ${delay}s before retry..."
              sleep $delay
              attempt=$((attempt + 1))
              delay=$((delay * 2))
            done
            
            return 1
          }
          
          deploy_with_retries
          
          echo "Configuring web app settings..."
          az webapp config appsettings set \
            --resource-group ${{ env.FRONTEND_RG }} \
            --name ${{ env.FRONTEND_APP_NAME }} \
            --settings \
              SCM_DO_BUILD_DURING_DEPLOYMENT=false \
              WEBSITE_NODE_DEFAULT_VERSION=18-lts \
              WEBSITE_RUN_FROM_PACKAGE=1 \
              WEBSITE_MEMORY_LIMIT_MB=128 \
              NODE_OPTIONS="--max-old-space-size=128" \
              NODE_ENV=production

    - name: Health check
      run: |
        check_health() {
          local url=$1
          local max_retries=5
          local retry=0
          local delay=30
          
          while [ $retry -lt $max_retries ]; do
            status=$(curl -sL -o /dev/null -w "%{http_code}" "$url" || echo "000")
            if [ "$status" = "200" ]; then
              echo "Frontend is healthy (Status: $status)"
              return 0
            fi
            
            echo "Frontend not ready (Status: $status), retrying in ${delay}s... (Attempt $((retry+1))/$max_retries)"
            sleep $delay
            retry=$((retry+1))
          done
          
          echo "Frontend failed health check after $max_retries attempts"
          return 1
        }

        check_health "https://${{ env.FRONTEND_APP_NAME }}.azurewebsites.net"
